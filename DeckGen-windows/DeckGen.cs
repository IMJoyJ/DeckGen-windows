using System;
using System.Collections.Generic;
using System.Data.SQLite;
using System.IO;
using System.Linq;

namespace DeckGen_windows
{
    class DeckGen
    {
        public const long   TYPE_FUSION         = 0x40      ;
        public const long   TYPE_SYNCHRO        = 0x2000    ;
        public const long   TYPE_XYZ            = 0x800000  ;
        public const long   TYPE_LINK           = 0x4000000 ;
        public event EventHandler<string> OnConsoleWrite;
        public void WriteLine(string line)
        {
            OnConsoleWrite(this, line);
        }
        public void Gen(object obj)
        {
            string[] args = obj as string[];
            string cdbFile = args[0];
            string lfListFile = args[1];
            string poolMainCardNum = args[2];
            string poolExCardNum = args[3];
            string numOfMain = args[4];
            string numOfEx = args[5];
            int deckNum = int.Parse(args[6]);
            foreach (string str in args)
            {
                this.WriteLine(str);
            }
            this.WriteLine("Reading lflist...");
            this.ReadLfList(lfListFile);
            this.WriteLine("Initialize card pool...");
            //There are only about 10K*3 cards for now(<300KB when use string). A initialize should be a better way.
            this.InitCardPool(cdbFile, int.Parse(poolMainCardNum), int.Parse(poolExCardNum));

            this.WriteLine("Generating decks...");
            int percent = 0;
            Directory.CreateDirectory("decks");
            for (int i = 0; i < deckNum; i++)
            {
                if (!this.GenerateDeck(int.Parse(numOfMain), int.Parse(numOfEx), $"decks{Path.DirectorySeparatorChar}output{i}.ydk"))
                {
                    break;
                }
                if (i * 100 / deckNum >= (percent + 10) / 10 * 10)
                {
                    percent = i * 100 / deckNum / 10 * 10;
                    this.WriteLine($"Completed {percent}%");
                }
            }
            this.WriteLine($"Completed 100%, adding spare cards to side deck...");
            CardPool.AddRange(CardPoolEx);
            for (int i = 0; i < deckNum; i++)
            {
                string deck = $"decks{Path.DirectorySeparatorChar}output{i}.ydk";
                if (i == deckNum)
                {
                    break;
                }
                if (!this.AddSideToDeck(deck))
                {
                    break;
                }
                if (!File.Exists(deck))
                {
                    break;
                }
            }
            this.WriteLine($"Completed, generating new lflist...");
            this.GenerateCardPoolLFList();
            this.WriteLine($"Completed!");
        }

        private bool AddSideToDeck(string deck)
        {
            FileStream fs = new FileStream(deck,FileMode.Append);
            StreamWriter sw = new StreamWriter(fs);
            for (int i = 0; i < 15; i++)
            {
                if (CardPool.Count == 0)
                {
                    sw.Close();
                    fs.Close();
                    return false;
                }
                int index = _rd.Next(CardPool.Count);
                sw.WriteLine(CardPool[index]);
                CardPool.RemoveAt(index);
            }
            sw.Close();
            fs.Close();
            return true;
        }

        private void GenerateCardPoolLFList()
        {
            FileStream fs = new FileStream("new-lflist.conf",FileMode.Create);
            StreamWriter sw = new StreamWriter(fs);
            sw.WriteLine("#Generated by DeckGen");
            sw.WriteLine("#!Special");
            sw.WriteLine("#forbidden");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 0
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 0");
            }
            sw.WriteLine("#limit");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 1
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 1");
            }
            sw.WriteLine("#semi limit");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 2
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 2");
            }
            sw.Close();
            fs.Close();
        }

        private void InitCardPool(string cdbFile, int mainNum, int exNum)
        {
            List<string> CardPoolLocal = new List<string>();
            List<string> CardPoolExLocal = new List<string>();
            SQLiteConnection sqlcon = new SQLiteConnection($"Data Source={cdbFile}");
            sqlcon.Open();
            SQLiteCommand cmd = new SQLiteCommand("SELECT id,type FROM datas", sqlcon);
            var reader = cmd.ExecuteReader();
            while (reader.Read())
            {
                string id = reader["id"].ToString();
                long type = (long)reader["type"];
                int num = 3;
                CardPoolLFList.Add(id, 0);
                if (LFList.ContainsKey(id))
                {
                    num = LFList[id];
                }
                if (((type & TYPE_FUSION) > 0) || ((type & TYPE_XYZ) > 0)
                    || ((type & TYPE_LINK) > 0) || ((type & TYPE_SYNCHRO) > 0))
                {
                    for (int i = 0; i < num; i++)
                    {
                        CardPoolExLocal.Add(id);
                    }
                }
                else
                {
                    for (int i = 0; i < num; i++)
                    {
                        CardPoolLocal.Add(id);
                    }
                }
            }
            for (int i = 0; i < mainNum; i++)
            {
                int index = _rd.Next(0, CardPoolLocal.Count);
                CardPool.Add(CardPoolLocal[index]);
                CardPoolLocal.RemoveAt(index);
                if (!CardPoolLFList.ContainsKey(CardPoolLocal[index]))
                {
                    CardPoolLFList.Add(CardPoolLocal[index], 1);
                }
                else
                {
                    CardPoolLFList[CardPoolLocal[index]]++;
                }
            }
            for (int i = 0; i < exNum; i++)
            {
                int index = _rd.Next(0, CardPoolExLocal.Count);
                CardPoolEx.Add(CardPoolExLocal[index]);
                CardPoolLFList[CardPoolExLocal[index]]++;
                CardPoolExLocal.RemoveAt(index);
            }
            reader.Close();
            cmd.Dispose();
            sqlcon.Dispose();
            CardPoolLocal.Clear();
            CardPoolExLocal.Clear();
        }

        static readonly Random _rd = new Random();
        private bool GenerateDeck(int numOfMain, int numOfEx, string file)
        {
            if (CardPool.Count < numOfMain || CardPoolEx.Count < numOfEx)
            {
                return false;
            }
            Dictionary<string,int> main = new Dictionary<string, int>();
            Dictionary<string,int> ex = new Dictionary<string, int>();
            for (int i = 0; i < numOfMain; i++)
            {
                int index = _rd.Next(CardPool.Count);
                if (main.ContainsKey(CardPool[index]))
                {
                    main[CardPool[index]]++;
                }
                else
                {
                    main.Add(CardPool[index], 1);
                }
                CardPool.RemoveAt(index);
            }
            for (int i = 0; i < numOfEx; i++)
            {
                if (CardPoolEx.Count == 0)
                {
                    break;
                }
                int index = _rd.Next(CardPoolEx.Count);
                if (ex.ContainsKey(CardPoolEx[index]))
                {
                    ex[CardPoolEx[index]]++;
                }
                else
                {
                    ex.Add(CardPoolEx[index], 1);
                }
                CardPoolEx.RemoveAt(index);
            }
            FileStream fs = new FileStream(file,FileMode.Create);
            StreamWriter sw = new StreamWriter(fs);
            sw.WriteLine("#created by DeckGen");
            sw.WriteLine("#main");
            foreach (var kvp in main)
            {
                for (int i = 0; i < kvp.Value; i++)
                {
                    sw.WriteLine(kvp.Key);
                }
            }
            sw.WriteLine("#extra");
            foreach (var kvp in ex)
            {
                for (int i = 0; i < kvp.Value; i++)
                {
                    sw.WriteLine(kvp.Key);
                }
            }
            sw.WriteLine("!side");
            sw.Close();
            fs.Close();
            main.Clear();
            ex.Clear();
            return true;
        }

        public Dictionary<string,int> LFList = new Dictionary<string, int>();
        public List<string> CardPool = new List<string>();
        public List<string> CardPoolEx = new List<string>();
        public Dictionary<string,int> CardPoolLFList = new Dictionary<string, int>();
        private void ReadLfList(string file)
        {
            FileStream fs = File.OpenRead(file);
            StreamReader sr = new StreamReader(fs);
            bool reading = false;
            for (string line = sr.ReadLine(); line != null; line = sr.ReadLine())
            {
                line = line.Trim();
                if (line.StartsWith("#"))
                {
                    continue;
                }
                if (line.StartsWith("!"))
                {
                    if (reading)
                    {
                        break;
                    }
                    reading = true;
                    continue;
                }
                if (line.Contains("--"))
                {
                    line = line.Substring(0, line.IndexOf("--"));
                    line = line.Trim();
                }
                string[] split = line.Split(' ');
                if (split.Length < 2)
                {
                    continue;
                }
                LFList.Add(split[0], int.Parse(split[1]));
            }
        }
    }
}
